---
layout: post
category : lessons
tagline: "Supporting tagline"
tags : [intro, beginner, jekyll, tutorial]
---
{% include JB/setup %}

## Domain-Driven Design

Now it is time to explain the fundamental [Domain-Driven Design](http://domaindrivendesign.org/books/) concepts in the DSL. If you don't have the book you can download and read more in [DDD Quickly](http://www.infoq.com/news/2006/12/domain-driven-design). It is highly recommended that you study one of these books, at least the concepts mentioned in this part of the tutorial.


### Domain Objects

In the DSL there are three types of Domain Objects.


#### Entity

Entities have an identity and the state of the object may change during the lifecycle.

> "There is a category of objects which seem to have an identity,
which remains the same throughout the states of the software.
For these objects it is not the attributes which matter, but a
thread of continuity and identity, which spans the life of a
system and can extend beyond it. Such objects are called Entities."
<small>Quote from [DDD Quickly](http://www.infoq.com/news/2006/12/domain-driven-design)</small>


#### ValueObject

For Value Objects the values of the attributes are interesting, and not which object it is. Value Objects are typically immutable.

> "There are cases when we need to contain some attributes of a
domain element. We are not interested in which object it is, but
what attributes it has. An object that is used to describe certain
aspects of a domain, and which does not have identity, is named
Value Object."
<small>Quote from [DDD Quickly](http://www.infoq.com/news/2006/12/domain-driven-design)</small>

Value Object is not the same as [Data Transfer Object](http://www.martinfowler.com/eaaCatalog/dataTransferObject.html). Core J2EE patterns caused a lot of confusion when they used the term Value Object. They have renamed it to [Transfer Object](http://www.oracle.com/technetwork/java/transferobject-139757.html).
{: .alert}


#### BasicType

BasicType is typically used for fundamental [types](http://www.martinfowler.com/ieeeSoftware/whenType.pdf), for example different [quantities](http://martinfowler.com/eaaDev/quantity.html) such as [Money](http://martinfowler.com/eaaCatalog/money.html),
or [range of values](http://martinfowler.com/eaaDev/Range.html).

BasicType is a ValueObject which is stored in the same table as the Domain Object referencing it. It corresponds to JPA `@Embeddable`.


### Aggregate

> "An Aggregate is a group of
associated objects which are considered as one unit with regard
to data changes. The Aggregate is demarcated by a boundary
which separates the objects inside from those outside. Each
Aggregate has one root. The root is an Entity, and it is the only
object accessible from outside. The root can hold references to
any of the aggregate objects, and the other objects can hold
references to each other, but an outside object can hold
references only to the root object."
<small>Quote from [DDD Quickly](http://www.infoq.com/news/2006/12/domain-driven-design)</small>

With Sculptor each Entity is by default an aggregate root, but you can use `!aggregateRoot` to define that it is not. Sculptor will validate the reference constraints described in the quote above.


### Repository

A repository is used for:

  * retrieving domain objects from the underlying database
  * persisting new domain objects
  * deleting domain objects

The interface of the Repository should always speak the Ubiquitous Language of the domain. It provides domain centric operations to the client. Repositories provide controlled access to the underlying data in the sense that it exposes only the Aggregate roots of the domain model.

> "Databases are part of the infrastructure. A poor solution is for
the client to be aware of the details needed to access a database.
...
Therefore, use a Repository, the purpose of which is to
encapsulate all the logic needed to obtain object references. The
domain objects won't have to deal with the infrastructure to get
the needed references to other objects of the domain. They will
just get them from the Repository and the model is regaining its
clarity and focus."
<small>Quote from [DDD Quickly](http://www.infoq.com/news/2006/12/domain-driven-design)</small>

You might feel confused regarding the difference between [DAO](http://www.oracle.com/technetwork/java/dataaccessobject-138824.html)s and repositories. The DAO is at a lower level of abstraction than the Repository and can contain plumbing codes to pull out data from the database. We typically have one DAO per database table, but one repository per domain type or aggregate.

I can recommend that you read [Inject Repositories, not DAOs in Domain Entities](http://debasishg.blogspot.com/2007/02/domain-driven-design-inject.html).


### Service

The Services act as a [Service Layer](http://martinfowler.com/eaaCatalog/serviceLayer.html) around the domain model. It provides a well defined interface with a set of available operations to the clients.

The transaction boundary is at the service layer.


### Module

> "Modules are used as a method of organizing related concepts
and tasks in order to reduce complexity.
...
Another reason for using modules is related to code quality. It is
widely accepted that software code should have a high level of
cohesion and a low level of coupling."
<small>Quote from [DDD Quickly](http://www.infoq.com/news/2006/12/domain-driven-design)</small>

With Sculptor the Modules are realized as Java packages. By default they are subpackages of the application package, but it is possible to define another package by specifying the `basePackage` attribute of the Module.

Circular references between Modules are not allowed. Interaction between a Service in one Module and a Repository in another Module is not allowed, it must go via a Service. Sculptor will validate these constraints.
